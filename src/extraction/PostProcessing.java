/****************************************************************/
/* Class PostProcessing                                         */
/* Reads classified data generated by a machine learning        */
/* classifier and prepares it to be converted into and RDF      */
/* graph                                                        */
/*                                                              */
/* Author: Vivian Silva                                         */
/****************************************************************/

package extraction;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import java.util.regex.Pattern;

import edu.stanford.nlp.trees.Tree;

public class PostProcessing {
	
	private static DefinitionParser dp;
	private static List<Integer> indexes = new ArrayList<Integer>();
	private static Vector<Vector<String>> noSupertype = new Vector<Vector<String>>();
	
	public PostProcessing(){
		
		try{
			dp = new DefinitionParser();
		}
		catch (IOException e){
			e.printStackTrace();
		}
	}
	
	//Read classified data in IOB format
	@SuppressWarnings("unchecked")
	private static Vector<Vector<String>> loadIOBFile(String inputfile){
		
		Vector<Vector<String>> definitions = new Vector<Vector<String>>();
    	
    	try{
			BufferedReader br = new BufferedReader(new FileReader(inputfile));
			try{
				String line = null;
				Vector<String> def = new Vector<String>();
				
				while ((line = br.readLine()) != null) {
					if (! line.equals("") && !line.equals("BOS O")){
						if (!line.equals("EOS O")){
							def.add(line);
						}
						else{
							definitions.add((Vector<String>)def.clone());
							def.clear();
						}
					}	
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		} catch (FileNotFoundException f){
			f.printStackTrace();
		}
    	
    	return definitions;
	}
	
	//Convert a text segment to the IOB format
	private static List<String> toIOB(List<String> def){
    	
    	List<String> newDef = new ArrayList<String>();
    	
    	for(String role : def){
    		String[] text = role.split(":")[0].split(" ");
    		String label = role.split(":")[1].replaceAll(" ", "_");
    			
    		if (label.equals("0")){
    			for (int i=0; i < text.length; i++){
    				newDef.add(text[i] + " O");
    			}
    		}
    		else{
    			newDef.add(text[0] + " B-" + label);
    			for (int i=1; i < text.length; i++){
    				newDef.add(text[i] + " I-" + label); 
    			}
    		}
    	}
    	
    	return newDef;
	}	
	
	//Look for definitions missing a supertype
	@SuppressWarnings({ "unchecked"})
	private static void checkSupertypes (Vector<Vector<String>> definitions){
	
		for (int i=0; i < definitions.size(); i++){
			Vector<String> def = definitions.get(i);
			if (!def.toString().contains("B-supertype") && !def.toString().contains("I-supertype")){
				noSupertype.add((Vector<String>)def.clone());
				indexes.add(i+1);
			}
		}
	}
	
	//Get only the definition's supertype
    private static List<String> getOnlySupertypes (String definition, String pos){
    	
    	List<String> roles = new ArrayList<String>();
		String expression = new String();
		
		pos = pos.equals("noun") ? "n" : "v";
		
		//Look for an accessory determiner at the beginning of the definition
		String accDet = dp.getAccessoryDeterminer(definition);
		
		if (!accDet.equals("") && !accDet.equals(definition)){
			roles.add(definition.indexOf(accDet.trim()) + "|" + accDet.trim() + "|accessory determiner");
			definition = definition.replaceFirst(accDet.trim(), "");
		}
		
		Tree parseTree = dp.parse(definition).get(0);
		
		List<String> conjunctions = new ArrayList<String>();
		int numConjunctions = 0;
		
		//Look for the supertypes
		String supertype = new String();
		List<String> firstNP = new ArrayList<String>();
		boolean verbSTfound = false;
		
		//For verbs
		if(pos.equals("v")){
			String head = definition.split(" ")[0];
			expression = "@/VB.?/";
			Tree vbTree = dp.getFirstTreeMatch(expression, parseTree);
			List<Tree> allVBs = dp.getAllTreeMatches(expression, parseTree);
			List<String> firstVB = new ArrayList<String>();
			
			String nextWord = new String();
			
			if (vbTree != null){
				firstVB = dp.getWordList(vbTree.yieldWords());
				
				//The first VB must also be the first word in the definition
				if (firstVB.get(0).equals(head) || allVBs.size() == 1){
					supertype = firstVB.get(0);
					verbSTfound = true;
					
					String newDef = definition;
				
					do{
						//Check if it is a phrasal verb
						expression = "PRT $- (@/VB.?/ < /" + supertype + "/)";
						Tree prtTree = dp.getFirstTreeMatch(expression, parseTree);
						List<String> prt = new ArrayList<String>();
				
						if(prtTree != null){
							prt = dp.getWordList(prtTree.yieldWords());
							supertype += " " + dp.toExpression(prt);
						}
				
						if (definition.contains(" '" + supertype)){
							supertype = "'" + supertype;
						}
						
						if (definition.contains(supertype + "'")){
							supertype = supertype + "'";
						}
						
						if (definition.contains(" -" + supertype)){
							supertype = "-" + supertype;
						}
						
						if (definition.contains(" *" + supertype)){
							supertype = "*" + supertype;
						}
						
						if (definition.indexOf(supertype) != 0 && definition.charAt(definition.indexOf(supertype)-1) != ' ' 
								&& (!Character.isAlphabetic(definition.charAt(definition.indexOf(supertype)-1))
										|| (Character.isAlphabetic(definition.charAt(definition.indexOf(supertype)-1))
												&& supertype.charAt(0) == '\''))){
							String temp = supertype;
							int idx = definition.indexOf(supertype)-1;
							char c = definition.charAt(idx);
							
							while (c != ' ' && idx >= 0){	
								temp = c + temp;
								
								if (idx != 0){
									idx--;
									c = definition.charAt(idx);
								}
								else{
									c = ' ';
								}
							}
							supertype = temp;
						}
						
						if (definition.contains(" " + supertype + " ")){
							roles.add((definition.indexOf(" " + supertype + " ")+1) + "|" + supertype + "|supertype");
						}
						else if (definition.contains(supertype + " ") && definition.indexOf(supertype + " ") == 0){
							roles.add(definition.indexOf(supertype + " ") + "|" + supertype + "|supertype");
						}
						else if (definition.contains(" " + supertype)){
							roles.add((definition.indexOf(" " + supertype)+1) + "|" + supertype + "|supertype");
						}
						else{
							roles.add(definition.indexOf(supertype) + "|" + supertype + "|supertype");
						}

						//Look for additional supertypes separated by conjunctions
						String toReplace = newDef.contains(supertype + " ") ? supertype + " " : supertype;
						newDef = newDef.replaceFirst(Pattern.quote(toReplace), "");
						
						if(newDef.contains(" ")){
							nextWord = newDef.substring(0, newDef.indexOf(" "));
					
							if (newDef.split(" ").length > 1){
								if(nextWord.equals("or") || nextWord.equals("and")){
									roles.add(definition.indexOf(newDef) + "|" + nextWord + "|0");
									supertype = newDef.split(" ")[1];
									newDef = newDef.replaceFirst(Pattern.quote(nextWord) + " ", "");
								}
							}
							else{
								nextWord = "";
							}
						}
						else{
							nextWord = "";
						}
					} while(nextWord.equals("or") || nextWord.equals("and"));
				}
			}
		}
		
		//For nouns or misclassified verbs
		if(pos.equals("n") || !verbSTfound){
			//expression = "@NP !<< @NP !<- POS << @/NN.?/ | <- @/NN.?/";
			expression = "@NP !<< @NP << @/NN.?/ | <- @/NN.?/";
			Tree supertypeTree = dp.getFirstTreeMatch(expression, parseTree);
			
			if (supertypeTree != null){
				firstNP = dp.getWordList(supertypeTree.yieldWords());
					
				//Check whether the NP contains conjunctions
				expression = "@CC";
				List<Tree> conjTrees = dp.getAllTreeMatches(expression, supertypeTree);
			
				if(conjTrees.size() > 0){
					for (Tree conjTree : conjTrees){
						conjunctions.addAll(dp.getWordList(conjTree.yieldWords()));
						numConjunctions = conjunctions.size();
					}
				}
			
				//Strip off leading determiner (the leftmost child of the NP), if any
				expression = "@DT  >>, @NP";
				Tree detTree = dp.getFirstTreeMatch(expression, supertypeTree);
				List<String> determiner = new ArrayList<String>();
			
				if (detTree != null){
					determiner = dp.getWordList(detTree.yieldWords());
				
					firstNP.remove(0);
					roles.add(definition.indexOf(determiner.get(0)) + "|" + determiner.get(0) + "|0");
				}
				
				//Strip off possessive marker (the rightmost child of the NP), if any
				expression = "POS";
				Tree posTree = dp.getFirstTreeMatch(expression, supertypeTree);
			
				if (posTree != null){
					firstNP.remove(firstNP.size()-1);
				}
			}
		
			supertype = dp.getLongestEntry(firstNP, pos, false).replaceAll("_", " ");
			
			//If the supertype wasn't found (due to parser error), get the first noun in the NP
			boolean skip = false;
			if (supertype.length() == 0){
				if (firstNP.size() > 0){
					expression = "@/NN.?/";
					Tree nounTree = dp.getFirstTreeMatch(expression, supertypeTree);
					List<String> firstNoun = new ArrayList<String>();
				
					if (nounTree != null){
						firstNoun = dp.getWordList(nounTree.yieldWords());
						supertype = firstNoun.get(0);
						skip = true;
					}
					else{//If no noun was found, get the last word
						supertype = firstNP.get(firstNP.size()-1);
					}
				}
				else{//If there's no NP in the sentence, get the rightmost word in the first ROOT's child
					expression = "__ >>- (__ >, ROOT)";
					Tree defaultTree = dp.getFirstTreeMatch(expression, parseTree);
					List<String> defaultST = new ArrayList<String>();
					
					if (defaultTree != null){
						defaultST = dp.getWordList(defaultTree.yieldWords());
						supertype = defaultST.get(0);
						
						//first word not alphanumeric, get the second one
						if ((!supertype.matches("([A-Za-z0-9\\-\\_]+)") || supertype.equals("-RRB-"))){
							if (defaultST.size() > 1)
								supertype  = defaultST.get(1);
							else
								supertype = "";
						}
						
						//discard invalid supertype
						if (supertype.equals("-RRB-")){
							supertype = "";
						}
					}
					else{ //last resort
						String[] tokens = definition.split(" ");
						supertype = tokens[tokens.length-1];
					}
				}
			}
			
			//Last check
			if (supertype.length() == 0){
				String[] tokens = definition.split(" ");
				supertype = tokens[tokens.length-1];
			}
			
			if (definition.contains(" '" + supertype)){
				supertype = "'" + supertype;
			}
			
			if (definition.contains(supertype + "'")){
				supertype = supertype + "'";
			}
			
			if (definition.contains(" -" + supertype)){
				supertype = "-" + supertype;
			}
			
			if (definition.contains(" *" + supertype)){
				supertype = "*" + supertype;
			}
			
			if (definition.indexOf(supertype) != 0 && definition.charAt(definition.indexOf(supertype)-1) != ' ' 
					&& !Character.isAlphabetic(definition.charAt(definition.indexOf(supertype)-1))){
				String temp = supertype;
				int idx = definition.indexOf(supertype)-1;
				char c = definition.charAt(idx);
				
				while (c != ' ' && idx >= 0){	
					temp = c + temp;
					
					if (idx != 0){
						idx--;
						c = definition.charAt(idx);
					}
					else{
						c = ' ';
					}
				}
				supertype = temp;
			}
			
			if (definition.contains(" " + supertype + " ")){
				roles.add((definition.indexOf(" " + supertype + " ")+1) + "|" + supertype + "|supertype");
			}
			else if (definition.contains(supertype + " ") && definition.indexOf(supertype + " ") == 0){
				roles.add(definition.indexOf(supertype + " ") + "|" + supertype + "|supertype");
			}
			else if (definition.contains(" " + supertype)){
				roles.add((definition.indexOf(" " + supertype)+1) + "|" + supertype + "|supertype");
			}
			else{
				roles.add(definition.indexOf(supertype) + "|" + supertype + "|supertype");
			}
			
			if (skip){
				String temp = dp.toExpression(firstNP).replaceFirst(Pattern.quote(supertype) + " ", "");
				firstNP = dp.toStringList(temp);
			}
			else{
				firstNP = dp.removeAllWords(firstNP, supertype.split(" ").length);
			}	
		
			//If there are conjunctions, check whether any of them are right before a supertype, and, if so,
			//look for additional supertypes
			String lastWord = firstNP.size() > 1 ? firstNP.get(firstNP.size()-1) : supertype;
			int offset = lastWord.equals("or") ? 3 : (lastWord.equals("and") ? 4 : 0);
				
			while(numConjunctions > 0 && (lastWord.equals("or") || lastWord.equals("and"))){
				roles.add(definition.indexOf(supertype)-offset + "|" + lastWord + "|0");
				firstNP = dp.removeAllWords(firstNP, 1);
			
				String addSupertype = dp.getLongestEntry(firstNP, pos, false).replaceAll("_", " ");
			
				roles.add(definition.indexOf(addSupertype) + "|" + addSupertype + "|supertype");
				firstNP = dp.removeAllWords(firstNP, addSupertype.split(" ").length);
				lastWord = firstNP.size() > 1 ? firstNP.get(firstNP.size()-1) : addSupertype;
				numConjunctions--;
			}
		}
		return roles;
    }

	//For definitions where a supertype was added, merge this role with previous identified ones
    @SuppressWarnings({ "unchecked" })
	private static Vector<Vector<String>> mergeSupertypes(List<List<String>> fixedSupertypes){
		
		Vector<Vector<String>> mergedSupertypes = new Vector<Vector<String>>();
		
		for (int i = 0; i < noSupertype.size(); i++){
			Vector<String> defToFix = noSupertype.get(i);
			List<String> fixedSup = toIOB(fixedSupertypes.get(i));
			Vector<String> newDef = new Vector<String>();
			
			for (int j=0; j < defToFix.size(); j++){
				String line = fixedSup.get(j);
				
				if (line.contains("B-supertype") || line.contains("I-supertype")){
					newDef.add(line);
				}
				else{
					newDef.add(defToFix.get(j));
				}
			}
			mergedSupertypes.add((Vector<String>)newDef.clone());
		}
		return mergedSupertypes;
	}
	
	//Merge fixed definitions (supertype added) and unchanged definitions
    private static Vector<Vector<String>> mergeAll(Vector<Vector<String>> allClassified, Vector<Vector<String>> mergedSupertypes){
		
		Vector<Vector<String>> newDefs = new Vector<Vector<String>>();
		
		int pointer = 0;
		int index = indexes.get(pointer);
		
		for (int i=0; i < allClassified.size(); i++){
			if (i == index-1){
				newDefs.add(mergedSupertypes.get(pointer));
				pointer++;
				
				if (pointer < indexes.size())
					index = indexes.get(pointer);
				
			}
			else{
				newDefs.add(allClassified.get(i));
			}
		}
		return newDefs;
	}
	
	//Look for inconsistent IOB sequences and fix them
    private static void fixLabels (Vector<Vector<String>> definitions, String outputfile){
		
		Vector<Vector<String>> newDefs = new Vector<Vector<String>>();
		
		for (Vector<String> def : definitions){
			Vector<String> newDef = def;
			boolean hasSupertype = true;
			
			newDef.add(0, "BOS O");
			
			if (!def.toString().contains("B-supertype")){
				hasSupertype = false;
			}
			
			for (int i = 0; i < def.size(); i++){
				String pair = def.get(i);
				String word = pair.split(" ")[0];

				if (!word.equals("")){
					String label = pair.split(" ")[1];
					String newLabel = label;
					
					//begin and outside labels don't need to be checked
					if (label.startsWith("I-")){
						if ((label.equals("I-supertype") && !hasSupertype) || i == 0){
							newLabel = label.replaceFirst("I-", "B-");
						}
						else{
							String lastLabel = def.get(i-1).split(" ")[1];
							
							//if label = I-xxx and last label = B-xxx or I-xxx, there's nothing to be done
							if (!lastLabel.replaceFirst("B-", "I-").equals(label) && !lastLabel.equals(label)){
								if (lastLabel.equals("O") || lastLabel.equals("B-supertype") || lastLabel.equals("I-supertype")){
									//if last label = O or a supertype label, convert inside label to begin label
									newLabel = label.replaceFirst("I-", "B-");
								}
								else{
									if (lastLabel.startsWith("I-")){
										//previous inside label has already been fixed, follow it
										newLabel = lastLabel;
									}
									else{
										//a different (non-supertype) begin label preceding this label
										if (lastLabel.startsWith("B-")){
											//last label in sentence, follow the begin label
											if (i == def.size()-1){
												newLabel = lastLabel.replaceFirst("B-", "I-");
											}
											else{
												String nextLabel = def.get(i+1).split(" ")[1];
												
												//next inside label different from current one, follow begin label
												if (! nextLabel.equals(label)){
													newLabel = lastLabel.replaceFirst("B-", "I-");
												}
												else{
													//next inside label equal to current one, change (non-supertype) begin label
													String lastPair = newDef.get(i-1);
													String newPair = lastPair.split(" ")[0] + " " + label.replaceFirst("I-", "B-");
													newDef.setElementAt(newPair, i-1);
												}
											}
										}
									}
								}
							}
						}
					}
					newDef.setElementAt(word + " " + newLabel, i);
				}
				else{
					newDef.remove(i);
				}
			}
			newDef.add("EOS O");
			newDefs.add(newDef);
		}
		
		try {
	        FileWriter writer = new FileWriter(outputfile);
	        for (Vector<String> def: newDefs){
	        	for (String line : def){
	        		writer.write(line);
	        		writer.write("\n");
	        	}	
	        	writer.write("\n");
	        }
	        writer.flush();
	        writer.close();
	    }catch(IOException e){  
			e.printStackTrace();
		}
		
		System.out.println("Classified definitions saved in the output folder.");
	}
	    
    public static void main (String args[]){
    	
    	new PostProcessing();
    	
    	//Load raw data (id|POS|word_list|def) and classified definitions in IOB format
    	List<String> definitions = dp.loadDataFile("input/definitions.txt");
    	Vector<Vector<String>> classified = loadIOBFile("input/classified_RNN.txt");
    	
    	//Get the definitions without a supertype and fix them
    	System.out.println("Checking definitions (this may take some time...)");
    	checkSupertypes(classified);
    	
		List<List<String>> supertypes = new ArrayList<List<String>>();
		
		for (int index : indexes){
			String def = definitions.get(index-1);
			String[] tokens = def.split("\\|");
			String pos = tokens[1];
			String gloss = tokens[3];

			supertypes.add(dp.sort(gloss, getOnlySupertypes(gloss, pos)));
		}
		
		//Merge the labels in classifications where supertypes were added
		Vector<Vector<String>> mergedSupertypes = mergeSupertypes(supertypes);
		
		//Merge all classifications (fixed supertypes and unchanged classifications)
		Vector<Vector<String>> newClassified = mergeAll(classified, mergedSupertypes);
		
		//Fix labels for all classifications
		fixLabels(newClassified, "output/classified_fixed.txt");
    }

}
